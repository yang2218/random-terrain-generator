import java.util.ArrayList;
import javax.vecmath.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.io.*;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;

import javax.media.opengl.*;
import javax.media.opengl.glu.GLU;
import javax.swing.JFrame;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3f;

import com.sun.opengl.util.BufferUtil;
import com.sun.opengl.util.FPSAnimator;
import com.sun.opengl.util.GLUT;

import java.util.ArrayList;

/*
The terrainGenerator generates a random fractal terrain by creating a 2D-matrix filled with 3D points.
The y-values of these points are retrieved from an x*x-vector (yVals) that contains a set of floating point 
values generated by the algorithm. The algorithm is known as the diamond-square algorithm and this implementation
is based on a texture map implementation retrieved here: http://www.gameprogrammer.com/fractal.html#selfsim
*/
public class TerrainGenerator {

    int dim;
    float min;
    float max;
    float seed;
    int stride;
    float len;
    int size;
    float[] yVals;
    boolean oddline;
    Vector3f[][] points;
    float tempRand;
    float fallOff = 1.f;
    float sharp;

    // Dimension: number of quads squared - Sharpness: sets "randomness" of topology - Length: length of mesh in space.
    TerrainGenerator(int dimension, float sharpness, float length) {
        dim = dimension;
        len = length;
        sharp = sharpness;
        min = (float) -sharpness*0.5f;
        max = (float) sharpness*0.6f;
        size = dim;
        size++;
        stride = dim / 2;
        points = new Vector3f[(int) size][(int) size];
        yVals = new float[size * size];
        generateSurface(points);
    }
    
    // Main function, outputs a 2D matrix of vector3f points.
    void generateSurface(Vector3f[][] points) {
        // The corner points should all be initialized to 0.
        yVals[0] = 0.f;
        yVals[dim] = 0.f;
        yVals[(size) * (size) - dim] = 0.f;
        yVals[(size) * (size) - 1] = 0.f;
        
        // This while-loop contains the algorithm. It will run until the variable stride is 0.
        // Stride is half the length of one side of the square which is halved until it hits zero.
        while (stride != 0) {
            for (int i = stride; i < dim; i += stride) {
                for (int j = stride; j < dim; j += stride) {
                    tempRand = generateRandom() * fallOff;
                    yVals[(i * size) + j] = tempRand + avgSquare(i, j);
                    j += stride;
                }
                i += stride;
            }
            oddline = false;
            for (int i = 0; i < dim; i += stride) {
                oddline = !oddline;
                for (int j = 0; j < dim; j += stride) {
                    tempRand = generateRandom() * fallOff;
                    if ((oddline)) {
                        j += stride;
                    }
                    yVals[(i * size) + j] = tempRand + avgDiamond(i, j);
                    if (i == 0) {
                        yVals[(dim * size) + j] =
                                yVals[(i * size) + j];
                    }
                    if (j == 0) {
                        yVals[(i * size) + dim] =
                                yVals[(i * size) + j];
                    }
                    if ((!oddline)) {
                        j += stride;
                    }
                }
            }
            stride >>= 1;
            // The fall off is set by "sharpness" parameter.
            // It reduces the effect of the random value at every pass through the loop to create smoother peaks and valleys.
            fallOff *= Math.log(sharp)/2;
        }
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                points[i][j] = new Vector3f((float) (len / dim) * i - (len / 2), yVals[i * size + j], (float) (len / dim) * j - (len / 2));
            }
        }
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                //System.out.println(i * size + j + "   " + points[i][j].x + " " + points[i][j].y + " " + points[i][j].z);
            }
        }
        //System.out.println(yVals.length);

    }
    // Generates a random value within the max-min range.
    float generateRandom() {
        return (float) Math.random() * (max - min) + min;
    }
    /*
    Computes "diamond"-points (*-points below) by averaging the center point X:
    0   *   0
    
    *   X   *
     
    0   *   0
    */
    float avgDiamond(int i, int j) {
        //System.out.println("diamond i: " + i + " j: " + j + " stride: " + stride);
        if (i == 0) {
            //System.out.println("diamond i=0:");
            return ((float) (yVals[(i * size) + j - stride]
                    + yVals[(i * size) + j + stride]
                    + yVals[((dim - stride) * size) + j]
                    + yVals[((i + stride) * size) + j]) * .25f);
        } else if (i == size - 1) {
            //System.out.println("diamond i=size-1:");
            return ((float) (yVals[(i * size) + j - stride]
                    + yVals[(i * size) + j + stride]
                    + yVals[((i - stride) * size) + j]
                    + yVals[((0 + stride) * size) + j]) * .25f);
        } else if (j == 0) {
            //System.out.println("diamond j=0:");
            return ((float) (yVals[((i - stride) * size) + j]
                    + yVals[((i + stride) * size) + j]
                    + yVals[(i * size) + j + stride]
                    + yVals[(i * size) + dim - stride]) * .25f);
        } else if (j == size - 1) {
            //System.out.println("diamond j=size-1:");
            return ((float) (yVals[((i - stride) * size) + j]
                    + yVals[((i + stride) * size) + j]
                    + yVals[(i * size) + j - stride]
                    + yVals[(i * size) + 0 + stride]) * .25f);
        } else {
            //System.out.println("diamond not on edge");
            return ((float) (yVals[((i - stride) * size) + j]
                    + yVals[((i + stride) * size) + j]
                    + yVals[(i * size) + j - stride]
                    + yVals[(i * size) + j + stride]) * .25f);
        }
    }
    /*
    Computes a center-point (a *-point below) by averaging the the four corner points (X):
    X   0   X
    
    0   *   0
     
    X   0   X
    */
    float avgSquare(int i, int j) {
        //System.out.println("square i: " + i + " j: " + j + " stride: " + stride);
        return (float) ((yVals[((i - stride) * size) + j - stride]
                + yVals[((i - stride) * size) + j + stride]
                + yVals[((i + stride) * size) + j - stride]
                + yVals[((i + stride) * size) + j + stride]) * .25f);

    }

}

